/**
 * GitHub Release Manager
 *
 * Creates releases when sprints are completed.
 * Generates release notes from completed features.
 */

import {
  createRelease,
  GitHubRelease,
  GitHubClientResult,
} from './client.js';
import { Feature, Sprint, FeatureList, getSprintProgress } from '../hero/feature-schema.js';

/**
 * Create a release for a completed sprint
 */
export async function createSprintRelease(
  featureList: FeatureList,
  sprintNumber: number,
  options: {
    tagPrefix?: string;
    draft?: boolean;
    prerelease?: boolean;
  } = {}
): Promise<GitHubClientResult<GitHubRelease>> {
  const sprint = featureList.sprints.find(s => s.number === sprintNumber);

  if (!sprint) {
    return { success: false, error: `Sprint ${sprintNumber} not found` };
  }

  // Get sprint features
  const sprintFeatures = featureList.features.filter(f => f.sprint === sprintNumber);

  // Check if sprint is complete
  const progress = getSprintProgress(featureList, sprintNumber);
  if (progress.percentage < 100) {
    return {
      success: false,
      error: `Sprint ${sprintNumber} is not complete (${progress.percentage}% verified)`,
    };
  }

  // Generate version tag
  const tagPrefix = options.tagPrefix || 'v';
  const version = generateVersion(featureList, sprintNumber);
  const tag = `${tagPrefix}${version}`;

  // Generate release title and notes
  const title = generateReleaseTitle(sprint, sprintNumber);
  const notes = generateReleaseNotes(sprint, sprintFeatures, featureList.project.name);

  return createRelease(tag, {
    title,
    notes,
    draft: options.draft,
    prerelease: options.prerelease,
  });
}

/**
 * Generate a version string based on sprint number
 */
function generateVersion(featureList: FeatureList, sprintNumber: number): string {
  // Simple versioning: 1.0.0 for sprint 1, 1.1.0 for sprint 2, etc.
  // Major.Minor.Patch where Minor = sprint - 1

  // Check for existing version in metadata
  const baseVersion = featureList.version || '1.0.0';
  const parts = baseVersion.split('.').map(p => parseInt(p, 10) || 0);

  // Increment minor version based on sprint
  return `${parts[0]}.${sprintNumber - 1}.0`;
}

/**
 * Generate release title
 */
function generateReleaseTitle(sprint: Sprint, sprintNumber: number): string {
  if (sprint.name) {
    return `Sprint ${sprintNumber}: ${sprint.name}`;
  }
  return `Sprint ${sprintNumber} Release`;
}

/**
 * Generate comprehensive release notes
 */
function generateReleaseNotes(
  sprint: Sprint,
  features: Feature[],
  projectName: string
): string {
  const sections: string[] = [];

  // Header
  sections.push(`# ${projectName} - Sprint ${sprint.number}`);

  // Sprint goal
  if (sprint.goal) {
    sections.push(`\n> ${sprint.goal}`);
  }

  // Features section
  sections.push('\n## What\'s New\n');

  // Group features by category (blocking vs non-blocking)
  const blockingFeatures = features.filter(f => f.blocking);
  const regularFeatures = features.filter(f => !f.blocking);

  if (blockingFeatures.length > 0) {
    sections.push('### Core Features\n');
    for (const feature of blockingFeatures) {
      sections.push(formatFeatureForRelease(feature));
    }
  }

  if (regularFeatures.length > 0) {
    sections.push('\n### Additional Features\n');
    for (const feature of regularFeatures) {
      sections.push(formatFeatureForRelease(feature));
    }
  }

  // Summary stats
  sections.push('\n## Summary\n');
  sections.push(`- **Features Completed**: ${features.length}`);
  sections.push(`- **Blocking Features**: ${blockingFeatures.length}`);

  // Calculate total steps and criteria
  const totalSteps = features.reduce((sum, f) => sum + f.steps.length, 0);
  const totalCriteria = features.reduce((sum, f) => sum + f.acceptanceCriteria.length, 0);

  if (totalSteps > 0) {
    sections.push(`- **Implementation Steps**: ${totalSteps}`);
  }
  if (totalCriteria > 0) {
    sections.push(`- **Acceptance Criteria Verified**: ${totalCriteria}`);
  }

  // Sprint dates
  if (sprint.startedAt) {
    const started = formatDate(sprint.startedAt);
    const completed = sprint.completedAt ? formatDate(sprint.completedAt) : 'ongoing';
    sections.push(`- **Duration**: ${started} - ${completed}`);
  }

  // Footer
  sections.push('\n---\n');
  sections.push('*This release was generated by [Claude Hero](https://github.com/ohmnow/claude-hero)*');

  return sections.join('\n');
}

/**
 * Format a single feature for release notes
 */
function formatFeatureForRelease(feature: Feature): string {
  const lines: string[] = [];

  // Feature name with checkmark
  lines.push(`- **${feature.name}**`);

  // Brief description
  if (feature.description) {
    // Truncate long descriptions
    const desc = feature.description.length > 150
      ? feature.description.slice(0, 147) + '...'
      : feature.description;
    lines.push(`  - ${desc}`);
  }

  return lines.join('\n');
}

/**
 * Format ISO date to readable string
 */
function formatDate(isoDate: string): string {
  try {
    const date = new Date(isoDate);
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
    });
  } catch {
    return isoDate;
  }
}

/**
 * Check if a sprint is ready for release
 */
export function isSprintReadyForRelease(
  featureList: FeatureList,
  sprintNumber: number
): { ready: boolean; reason?: string } {
  const sprint = featureList.sprints.find(s => s.number === sprintNumber);

  if (!sprint) {
    return { ready: false, reason: `Sprint ${sprintNumber} not found` };
  }

  const sprintFeatures = featureList.features.filter(f => f.sprint === sprintNumber);

  if (sprintFeatures.length === 0) {
    return { ready: false, reason: 'Sprint has no features' };
  }

  const progress = getSprintProgress(featureList, sprintNumber);

  if (progress.percentage < 100) {
    const remaining = progress.total - progress.verified;
    return {
      ready: false,
      reason: `${remaining} feature(s) not yet verified (${progress.percentage}% complete)`,
    };
  }

  return { ready: true };
}

/**
 * Get release context for prompt injection
 */
export function getReleaseContext(
  featureList: FeatureList,
  currentSprint: number
): string {
  const readiness = isSprintReadyForRelease(featureList, currentSprint);

  if (readiness.ready) {
    return `Sprint ${currentSprint} is ready for release! All features verified.`;
  }

  return `Sprint ${currentSprint}: ${readiness.reason}`;
}
