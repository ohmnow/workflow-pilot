/**
 * GitHub Issue Manager
 *
 * Creates and manages GitHub issues from feature_list.json features.
 * Handles two-way sync between local features and GitHub issues.
 */

import {
  createIssue,
  updateIssue,
  closeIssue,
  listOpenIssues,
  GitHubIssue,
  GitHubClientResult,
} from './client.js';
import { Feature, AcceptanceCriterion } from '../orchestrator/feature-schema.js';

/**
 * Extended feature with GitHub integration fields
 */
export interface GitHubFeature extends Feature {
  githubIssue?: number;
  githubPR?: number;
  githubBranch?: string;
}

/**
 * Create a GitHub issue from a feature
 */
export async function createIssueFromFeature(
  feature: Feature
): Promise<GitHubClientResult<GitHubIssue>> {
  const body = formatFeatureBody(feature);
  const labels = getFeatureLabels(feature);

  return createIssue(feature.name, body, { labels });
}

/**
 * Create issues for all features in a list
 */
export async function createIssuesForFeatures(
  features: Feature[]
): Promise<Map<string, GitHubIssue>> {
  const results = new Map<string, GitHubIssue>();

  for (const feature of features) {
    // Skip if already has an issue
    const ghFeature = feature as GitHubFeature;
    if (ghFeature.githubIssue) {
      continue;
    }

    const result = await createIssueFromFeature(feature);
    if (result.success && result.data) {
      results.set(feature.id, result.data);
    }
  }

  return results;
}

/**
 * Update a GitHub issue from feature changes
 */
export async function updateIssueFromFeature(
  feature: GitHubFeature
): Promise<GitHubClientResult<void>> {
  if (!feature.githubIssue) {
    return { success: false, error: 'Feature has no linked GitHub issue' };
  }

  const body = formatFeatureBody(feature);
  const labels = getFeatureLabels(feature);

  // Check if feature is complete
  if (feature.status === 'verified' && feature.passes) {
    // Close the issue
    return closeIssue(feature.githubIssue, 'Feature verified and complete!');
  }

  return updateIssue(feature.githubIssue, { body, labels });
}

/**
 * Close a GitHub issue when feature is complete
 */
export async function closeFeatureIssue(
  feature: GitHubFeature,
  comment?: string
): Promise<GitHubClientResult<void>> {
  if (!feature.githubIssue) {
    return { success: false, error: 'Feature has no linked GitHub issue' };
  }

  const defaultComment = `Feature "${feature.name}" has been verified and completed.`;
  return closeIssue(feature.githubIssue, comment || defaultComment);
}

/**
 * Get open issues that may correspond to features
 */
export async function getOpenFeatureIssues(): Promise<GitHubClientResult<GitHubIssue[]>> {
  return listOpenIssues({ labels: ['feature'] });
}

/**
 * Format feature as GitHub issue body
 */
function formatFeatureBody(feature: Feature): string {
  const sections: string[] = [];

  // Description
  sections.push(`## Description\n\n${feature.description}`);

  // Dependencies
  if (feature.dependsOn.length > 0) {
    sections.push(`## Dependencies\n\n${feature.dependsOn.map(d => `- Depends on: \`${d}\``).join('\n')}`);
  }

  // Blocking status
  if (feature.blocking) {
    sections.push(`> **Blocking Feature**: Other features depend on this one.`);
  }

  // Steps
  if (feature.steps.length > 0) {
    const stepsText = feature.steps
      .map(s => `- [${s.completed ? 'x' : ' '}] ${s.description}`)
      .join('\n');
    sections.push(`## Implementation Steps\n\n${stepsText}`);
  }

  // Acceptance Criteria
  if (feature.acceptanceCriteria.length > 0) {
    const criteriaText = feature.acceptanceCriteria
      .map(c => formatCriterion(c))
      .join('\n');
    sections.push(`## Acceptance Criteria\n\n${criteriaText}`);
  }

  // Status footer
  sections.push(`---\n\n*Sprint ${feature.sprint} | Status: ${feature.status} | Verified: ${feature.passes ? 'Yes' : 'No'}*`);

  // Workflow Pilot attribution
  sections.push(`\n*Generated by [Workflow Pilot](https://github.com/ohmnow/workflow-pilot)*`);

  return sections.join('\n\n');
}

/**
 * Format an acceptance criterion as checklist item
 */
function formatCriterion(criterion: AcceptanceCriterion): string {
  const checked = criterion.verified ? 'x' : ' ';
  let text = `- [${checked}] ${criterion.description}`;

  if (criterion.verified && criterion.verifiedAt) {
    text += ` *(verified ${formatDate(criterion.verifiedAt)})*`;
  }

  if (criterion.notes) {
    text += `\n  - Note: ${criterion.notes}`;
  }

  return text;
}

/**
 * Get labels for a feature
 */
function getFeatureLabels(feature: Feature): string[] {
  const labels: string[] = ['feature'];

  // Sprint label
  labels.push(`sprint-${feature.sprint}`);

  // Status labels
  switch (feature.status) {
    case 'blocked':
      labels.push('blocked');
      break;
    case 'in_progress':
      labels.push('in-progress');
      break;
    case 'implemented':
      labels.push('needs-review');
      break;
    case 'verified':
      labels.push('verified');
      break;
  }

  // Blocking label
  if (feature.blocking) {
    labels.push('blocking');
  }

  // Priority label
  if (feature.priority !== undefined) {
    if (feature.priority <= 1) {
      labels.push('priority-high');
    } else if (feature.priority <= 3) {
      labels.push('priority-medium');
    } else {
      labels.push('priority-low');
    }
  }

  return labels;
}

/**
 * Format ISO date to readable string
 */
function formatDate(isoDate: string): string {
  try {
    const date = new Date(isoDate);
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
    });
  } catch {
    return isoDate;
  }
}

/**
 * Generate summary of issues to create
 */
export function generateIssueSummary(features: Feature[]): string {
  const byStatus = new Map<string, number>();
  const bySprint = new Map<number, number>();

  for (const feature of features) {
    // Count by status
    byStatus.set(feature.status, (byStatus.get(feature.status) || 0) + 1);
    // Count by sprint
    bySprint.set(feature.sprint, (bySprint.get(feature.sprint) || 0) + 1);
  }

  const statusText = Array.from(byStatus.entries())
    .map(([status, count]) => `  ${status}: ${count}`)
    .join('\n');

  const sprintText = Array.from(bySprint.entries())
    .sort((a, b) => a[0] - b[0])
    .map(([sprint, count]) => `  Sprint ${sprint}: ${count} features`)
    .join('\n');

  return `GitHub Issues to Create: ${features.length}\n\nBy Status:\n${statusText}\n\nBy Sprint:\n${sprintText}`;
}
